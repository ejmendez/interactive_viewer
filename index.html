<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Interactive viewer</title>

</head>

<body>
      <button onclick="enableSong()">Start</button>
</body>

<script>

    //Probarlo
    //Vibracion
    //Poner websocket en la red
    //Como poner un client en la red
    //Dividir imagenes, rompecabezas
    //Poner user name
    //Hacer prueba con muchos users
    //Imagenes
    //Videos
    //Encuentas
    //Colores random

    let light = false

    let song_in_progress = -1;

    let track = "";

    let canVibrate = false;
    if('vibrate' in navigator) {
      canVibrate = true;
    }

    function vibrate() {
      //console.log("Vibration "+ canVibrate)
      if (canVibrate) {
        navigator.vibrate(1500);
      }
      //navigator.vibrate(0)
    }

    //const socket = new WebSocket('ws://192.168.100.11:8080');
    const socket = new WebSocket('wss://interactiveviewer.glitch.me/?user-agent=Mozilla');

    function enableSong() {
        song_in_progress = 0
    };

    function songFinishes() {
        song_in_progress = 0
    };

    function turnLight(mode) {

        if(track) {
            //console.log("Turning " + mode + " light")
            const constraints = {
                advanced: [{
                    torch:mode,
                }]
            };

            track.applyConstraints(constraints)
                .then(() => {
                console.log("Successful action with the light")
            })
        }
    }

    socket.addEventListener('open', function (event) {
        socket.send('Connection Established');
            document.body.style.backgroundColor = "#ff0000";
            return false;
    });

    socket.addEventListener('message', function (event) {
        //console.log(event.data);
        //console.log("light " + light);

        let rgbX_array = event.data.split(",")
        let effect     = rgbX_array[3]

        document.body.style.backgroundColor = "rgb" + "(" + rgbX_array[0] + ", " + rgbX_array[1] + ", " + rgbX_array[2] + ")";

        let play_audio = 0
        let src        = ""

        if (song_in_progress == 0) {
            if (effect == 100) {
                src        = 'https://drive.google.com/uc?export=view&id=14zo4q1ffJiWerIu6Nhm7N9To1p552ieu';
                play_audio = 1
            }
            else if (effect == 101) {
                src        = 'https://drive.google.com/uc?export=view&id=155Hh49l3gYjIodUjqhTHDoy4Hm6XF_vR';
                play_audio = 1
            }

            if (play_audio == 1) {
                song_in_progress = 1

                let audio = new Audio(src);
                audio.addEventListener("ended", songFinishes);
                audio.play();
            }
        }

        if (effect == 10) {
            vibrate()
        }

        if (effect == 255 && light == false) {
            turnLight(true)
            light = true
        }
        else if (effect == 0 && light == true) {
            turnLight(false)
            light = false
        }
    });

    const contactServer = () => {
        socket.send("Initialize");
    }

    function enableCameraLight() {
        //Test browser support
        const SUPPORTS_MEDIA_DEVICES = 'mediaDevices' in navigator;

        if (SUPPORTS_MEDIA_DEVICES) {
          //Get the environment camera (usually the second one)
          navigator.mediaDevices.enumerateDevices().then(devices => {

            const cameras = devices.filter((device) => device.kind === 'videoinput');

            if (cameras.length === 0) {
              throw 'No camera found on this device.';
            }
            const camera = cameras[cameras.length - 1];


            // Create stream and get video track
            navigator.mediaDevices.getUserMedia({
              video: {
                deviceId: camera.deviceId,
                facingMode: ['user', 'environment'],
                height: {ideal: 1080},
                width: {ideal: 1920}
              }
            }).then(stream => {

                track = stream.getVideoTracks()[0];

                capabilities = track.getCapabilities()

                if (!capabilities.torch) {
                    console.log("torch is not supported")
                    track.stop()
                    console.log("torch is not supported")
                    track= ""
                }
            });


          });
          //The light will be on as long the track exists
        }
    }


    const canWakeLock = () => 'wakeLock' in navigator;

    let wakelock;

    async function lockWakeState() {

        console.log("Checking if screen can be locked")
        if(!canWakeLock()) return;
            try {
                wakelock = await navigator.wakeLock.request();
                wakelock.addEventListener('release', () => {
                console.log('Screen Wake State Locked:', !wakelock.released);
            });
            console.log('Screen Wake State Locked:', !wakelock.released);
        } catch(e) {
            console.error('Failed to lock wake state with reason:', e.message);
        }
    }

    enableCameraLight()
    lockWakeState()

</script>

</html>
